////////////////////////////////// Criado por: Felipe Granado //////////////////////////////////#define _CRT_SECURE_NO_WARNINGS#include "RaceDirector.hpp"#include <chrono>#include <filesystem>#include <fstream>using namespace std;namespace fs = filesystem;// plugin informationextern "C" __declspec( dllexport )const char * __cdecl GetPluginName()                   { return( "Race Director - 2025.06.10" ); }extern "C" __declspec( dllexport )PluginObjectType __cdecl GetPluginType()               { return( PO_INTERNALS ); }extern "C" __declspec( dllexport )int __cdecl GetPluginVersion()                         { return( 7 ); }  // Funcionalidade do InternalsPluginV07 (se voce mudar esse valor de retorno, deve derivar da classe apropriada!)extern "C" __declspec( dllexport )PluginObject * __cdecl CreatePluginObject()            { return( static_cast< PluginObject * >( new RaceDirectorPlugin ) ); }extern "C" __declspec( dllexport )void __cdecl DestroyPluginObject( PluginObject *obj )  { delete( static_cast< RaceDirectorPlugin * >( obj ) ); }// StartControl sc;RaceDirectorPlugin::RaceDirectorPlugin()    : mNumPilotos(0), mMaxPilotos(0), mFase(0), mAtualizaTelemetria(true), mLogHabilitado(true), mAplicaPenalidade(false), mStartControlEnabled(false), mStartControlGear(0), mStartControlLimiter(false), mStartControlMaxVelKPH(80.0), mStartControlPenalty(-3) {}RaceDirectorPlugin::~RaceDirectorPlugin(){    // Destrutor do plugin, se necessário.    if( mLogArquivo.is_open() )    {        mLogArquivo.close();    }    // Se você tiver alocado memória ou recursos, libere-os aqui.    // Por exemplo, se você tiver um ponteiro para um arquivo aberto, feche-o.    // Limpar a lista de pilotos, se necessário.    mPilotos.clear();    // Limpar o caminho local, se necessário.	mLogLocal.clear();}void RaceDirectorPlugin::StartSession(){    GerarLog();    EscreverLog( "Log criado: " + mLogLocal );    EscreverLog(         "Controle de largada: " + to_string(mStartControlEnabled) +        "\t| Marcha: " + to_string(mStartControlGear) +        "\t| Limitador: " + to_string(mStartControlLimiter) +        "\t| Vel Maxima : " + to_string(mStartControlMaxVelKPH) +        "\t| Penalidade : " + to_string(mStartControlPenalty) +        "\n"    );    EscreverLog( "---------- SESSAO INICIADA ----------" );}void RaceDirectorPlugin::UpdateScoring(const ScoringInfoV01& info){    if (info.mSession >= 10)    {        mNumPilotos = info.mNumVehicles;        mMaxPilotos = info.mMaxPlayers;        if (mFase != info.mGamePhase)        {            mFase = info.mGamePhase;            mPilotos.clear();            mPilotos.reserve(mMaxPilotos);            for (int i = 0; i < mNumPilotos; ++i)            {                const VehicleScoringInfoV01& vsi = info.mVehicle[i];                PilotoInfo piloto;                piloto.mIndex = i;                piloto.mID = vsi.mID;                piloto.mNome = vsi.mDriverName;                piloto.mVeiculo = vsi.mVehicleName;                piloto.mClasse = vsi.mVehicleClass;                piloto.mEmPit = vsi.mInPits;                mPilotos.push_back(piloto);            }            mAtualizaTelemetria = true;            // Verificar controles            if (mFase == 5) {                ostringstream oss;                oss << "Pista: " << info.mTrackName << "\t| Pilotos: " << info.mNumVehicles << "\t| Sessao: " << info.mSession << "\t| Fase: " << info.mGamePhase << "\t| Tempo: " << info.mCurrentET;                                EscreverLog(oss.str());                CheckStartControl();            }            if (mFase == 4) {                // CheckMulticlassQualifying();            }            if (mFase == 6) {                // CheckFullCourseYellow();            }        }    }}long RaceDirectorPlugin::WantsTelemetryUpdates(){    if (mAtualizaTelemetria)    {        mAtualizaTelemetria = false;        return(2);    }    else    {        return (0);    }}void RaceDirectorPlugin::UpdateTelemetry(const TelemInfoV01& info){    double velMPH = sqrt(info.mLocalVel.x * info.mLocalVel.x + info.mLocalVel.y * info.mLocalVel.y + info.mLocalVel.z * info.mLocalVel.z) * 2.23694;    double velKPH = sqrt(info.mLocalVel.x * info.mLocalVel.x + info.mLocalVel.y * info.mLocalVel.y + info.mLocalVel.z * info.mLocalVel.z) * 3.6;        for(auto& piloto : mPilotos)    {        if (piloto.mID == info.mID)        {            piloto.mVelMPH = velMPH;            piloto.mVelKPH = velKPH;            piloto.mMarcha = info.mGear;            piloto.mLimitador = info.mSpeedLimiter;            break; // Encontrou o piloto, não precisa continuar o loop.        }	}}bool RaceDirectorPlugin::WantsToDisplayMessage(MessageInfoV01& msgInfo){    if (!mMensagem.empty()) {        strcpy_s(msgInfo.mText, mMensagem.c_str());        msgInfo.mDestination = 1;        msgInfo.mTranslate = 0;        EscreverLog("Mensagem enviada: " + mMensagem);        mMensagem.clear(); // Limpar a mensagem após enviá-la.        return true;    }    return false;}void RaceDirectorPlugin::SetEnvironment(const EnvironmentInfoV01& info){    mLogLocal = string(info.mPath[0]) + "Log\\RaceDirector\\";    if (!fs::exists(mLogLocal))    {        fs::create_directories(mLogLocal);    }}bool RaceDirectorPlugin::GetCustomVariable(long i, CustomVariableV01& var){    switch (i)    {    case 0: strcpy_s(var.mCaption, " Enabled"); var.mNumSettings = 2; var.mCurrentSetting = 1; return(true); // rF2 criará automaticamente esta variável e a padronizará como 1 (true), a menos que a criemos primeiro, caso em que podemos escolher o padrão.    case 1: strcpy_s(var.mCaption, "LogRegister"); var.mNumSettings = 2; var.mCurrentSetting = 1; return(true); // se deseja criar log de registro, padronizado como 1 (true)    case 2: strcpy_s(var.mCaption, "Language"); var.mNumSettings = 3; var.mCurrentSetting = 0; return(true); // Idioma    case 3:strcpy_s(var.mCaption, "Penalty"); var.mNumSettings = 64; var.mCurrentSetting = -1; return(true);    case 4: strcpy_s(var.mCaption, "StartControl.Enabled"); var.mNumSettings = 2; var.mCurrentSetting = 0; return(true);    case 5: strcpy_s(var.mCaption, "StartControl.Gear"); var.mNumSettings = 10; var.mCurrentSetting = 0; return(true);    case 6: strcpy_s(var.mCaption, "StartControl.Limiter"); var.mNumSettings = 2; var.mCurrentSetting = 0; return(true);    case 7: strcpy_s(var.mCaption, "StartControl.MaxSpeedKPH"); var.mNumSettings = 999; var.mCurrentSetting = 80; return(true);    case 8: strcpy_s(var.mCaption, "StartControl.Penalty"); var.mNumSettings = 64; var.mCurrentSetting = -3; return(true);    }    return(false);}void RaceDirectorPlugin::GetCustomVariableSetting(CustomVariableV01& var, long i, CustomSettingV01& setting){    if (0 == _stricmp(var.mCaption, " Enabled"))    {        if (0 == i)            strcpy_s(setting.mName, "False");        else            strcpy_s(setting.mName, "True");    }    else if (0 == _stricmp(var.mCaption, "LogRegister"))    {        if (0 == i)            strcpy_s(setting.mName, "False");        else            strcpy_s(setting.mName, "True");    }    else if (0 == _stricmp(var.mCaption, "Language"))    {        if (0 == i)            strcpy_s(setting.mName, "en");        else if (1 == i)            strcpy_s(setting.mName, "pt");    }    else if (0 == _stricmp(var.mCaption, "Penalty"))    {        if (-3 == i)            sprintf_s(setting.mName, "Do Nothing");        else if (-2 == i)            sprintf_s(setting.mName, "Longest Line");        else if (-1 == i)            sprintf_s(setting.mName, "Drive-Thru");        else if (0 <= i)            sprintf_s(setting.mName, "Stop&Go # seconds");    }    else if (0 == _stricmp(var.mCaption, "StartControl.Enabled"))    {        if (i == 0)            sprintf_s(setting.mName, "False");        else if (i == 1)            sprintf_s(setting.mName, "True");    }    else if (0 == _stricmp(var.mCaption, "StartControl.Gear"))    {        if (i == 0)            sprintf_s(setting.mName, "Disabled");        else if (i > 0)            sprintf_s(setting.mName, "%d", mStartControlGear);    }    else if (0 == _stricmp(var.mCaption, "StartControl.Limiter"))    {        if (i == 0)            sprintf_s(setting.mName, "Disabled");        else if (i == 1)            sprintf_s(setting.mName, "Enabled");    }    else if (0 == _stricmp(var.mCaption, "StartControl.MaxVelKPH"))    {        if (i < 0)            sprintf_s(setting.mName, "Disabled");        else            sprintf_s(setting.mName, "%.3f", mStartControlMaxVelKPH);    }    else if (0 == _stricmp(var.mCaption, "StartControl.Penalty"))    {        if (i == -3)            sprintf_s(setting.mName, "Disabled");        else if (i == -2)            sprintf_s(setting.mName, "Longest Line");        else if (i == -1)            sprintf_s(setting.mName, "Drive-Thru");        else if (i >= 0 && i <= 60)            sprintf_s(setting.mName, "Stop&Go %ds", mStartControlPenalty);    }}void RaceDirectorPlugin::AccessCustomVariable(CustomVariableV01& var){    if (0 == _stricmp(var.mCaption, " Enabled"))    {        // Nao faca nada; esta variavel e apenas para o rF2 saber se deve manter o plugin carregado.    }    else if (0 == _stricmp(var.mCaption, "LogRegister"))    {        mLogHabilitado = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "Language"))    {        rdIdioma = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "Penalty"))    {        rdPenalidade = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Enabled"))    {        mStartControlEnabled = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Gear"))    {        mStartControlGear = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Limiter"))    {        mStartControlLimiter = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.MaxVelKPH"))    {        mStartControlMaxVelKPH = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Penalty"))    {        mStartControlPenalty = var.mCurrentSetting;    }}void RaceDirectorPlugin::GerarLog(){    auto agora = chrono::system_clock::now();    time_t t = chrono::system_clock::to_time_t(agora);    tm now;    localtime_s(&now, &t);    ostringstream oss;    oss << mLogLocal << "RD-" << put_time(&now, "%Y_%m_%d-%H_%M_%S") << ".txt";    mLogLocal = oss.str();    mLogArquivo.open(mLogLocal, ios::app);}// Escrever o Log no arquivo criadovoid RaceDirectorPlugin::EscreverLog(const string& msg){    ostringstream log;    if (mLogHabilitado && mLogArquivo.is_open())    {        mLogArquivo << msg << endl;        mLogArquivo.flush(); // Garante que o log seja escrito imediatamente.    }}void RaceDirectorPlugin::CheckStartControl(){    if (mStartControlEnabled)    {        EscreverLog("Bandeira VERDE, iniciando controle de Largada...");        for (auto& piloto : mPilotos)        {            if (!piloto.mEmPit)            {                ostringstream log;                if (piloto.mVelKPH > mStartControlMaxVelKPH)                {                    mAplicaPenalidade = true;                    log << "Velocidade excedida: " << piloto.mNome << " (" << piloto.mVelKPH << " km/h" << ")";                }                else if (piloto.mMarcha != mStartControlGear)                {                    mAplicaPenalidade = true;                    log << "Marcha incorreta: " << piloto.mNome << " (Marcha: " << piloto.mMarcha << ")";                }                else if (piloto.mLimitador != mStartControlLimiter)                {                    mAplicaPenalidade = true;                    log << "Limitador desligado: " << piloto.mNome;                }                if (mAplicaPenalidade)                {                    ostringstream oss;                    oss << "/addpenalty " << mStartControlPenalty << " " << piloto.mNome;                    mMensagem = oss.str();                    EscreverLog(log.str()); // Log da penalidade aplicada.                }                else                {                    EscreverLog("Piloto " + piloto.mNome + " cumpriu os requisitos de largada."); // Log de sucesso.                }            }         }    }}