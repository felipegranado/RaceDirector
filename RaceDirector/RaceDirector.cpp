////////////////////////////////// Criado por: Felipe Granado //////////////////////////////////#define _CRT_SECURE_NO_WARNINGS#include "RaceDirector.hpp"#include <chrono>#include <filesystem>#include <fstream>using namespace std;namespace fs = filesystem;// plugin informationextern "C" __declspec( dllexport )const char * __cdecl GetPluginName()                   { return( "Race Director - 2025.06.10" ); }extern "C" __declspec( dllexport )PluginObjectType __cdecl GetPluginType()               { return( PO_INTERNALS ); }extern "C" __declspec( dllexport )int __cdecl GetPluginVersion()                         { return( 7 ); }  // Funcionalidade do InternalsPluginV07 (se voce mudar esse valor de retorno, deve derivar da classe apropriada!)extern "C" __declspec( dllexport )PluginObject * __cdecl CreatePluginObject()            { return( static_cast< PluginObject * >( new RaceDirectorPlugin ) ); }extern "C" __declspec( dllexport )void __cdecl DestroyPluginObject( PluginObject *obj )  { delete( static_cast< RaceDirectorPlugin * >( obj ) ); }// StartControl sc;RaceDirectorPlugin::RaceDirectorPlugin(){    // Inicializar o caminho do log local.    mLogLocal.clear();    mMensagem.clear();    mPilotos.clear();    mNumPilotos = -1;    mMaxPilotos = -1;    mFase = -1;    mAtualizaTelemetria = false;    mAplicaPenalidade = false;    // CustomVariables - Log    mLogHabilitado = false;    // CustomVariables - StartControl.    mStartControlEnabled = false;    mStartControlGear = -1;    mStartControlLimiter = false;    mStartControlMaxVelKPH = -1;    mStartControlPenalty = -3;    // Inicializar variáveis de idioma.    mIdioma = -1;}RaceDirectorPlugin::~RaceDirectorPlugin(){    // Destrutor do plugin, se necessário.    if( mLogArquivo.is_open() )    {        mLogArquivo.close();    }    mPilotos.clear();	mLogLocal.clear();}void RaceDirectorPlugin::StartSession(){    GerarLog();    EscreverLog( "Log criado: " + mLogLocal );    EscreverLog(         "Controle de largada: " + to_string(mStartControlEnabled) +        "\t| Marcha: " + to_string(mStartControlGear) +        "\t| Limitador: " + to_string(mStartControlLimiter) +        "\t| Vel Maxima : " + to_string(mStartControlMaxVelKPH) +        "\t| Penalidade : " + to_string(mStartControlPenalty) +        "\n"    );    EscreverLog( "---------- SESSAO INICIADA ----------" );}void RaceDirectorPlugin::UpdateScoring(const ScoringInfoV01& info){    if (info.mSession >= 10)    {        mNumPilotos = info.mNumVehicles;        mMaxPilotos = info.mMaxPlayers;        if (mFase != info.mGamePhase)        {            mFase = info.mGamePhase;            mPilotos.clear();            mPilotos.reserve(mMaxPilotos);            for (int i = 0; i < mNumPilotos; ++i)            {                const VehicleScoringInfoV01& vsi = info.mVehicle[i];                PilotoInfo piloto;                piloto.mIndex = i;                piloto.mID = vsi.mID;                piloto.mNome = vsi.mDriverName;                piloto.mVeiculo = vsi.mVehicleName;                piloto.mClasse = vsi.mVehicleClass;                piloto.mEmPit = vsi.mInPits;                mPilotos.push_back(piloto);            }            mAtualizaTelemetria = true;            // Verificar controles            if (mFase == 5) {                ostringstream oss;                oss << "Pista: " << info.mTrackName << "\t| Pilotos: " << info.mNumVehicles << "\t| Sessao: " << info.mSession << "\t| Fase: " << info.mGamePhase << "\t| Tempo: " << info.mCurrentET;                                EscreverLog(oss.str());                CheckStartControl();            }            if (mFase == 4) {                // CheckMulticlassQualifying();            }            if (mFase == 6) {                // CheckFullCourseYellow();            }        }    }}long RaceDirectorPlugin::WantsTelemetryUpdates(){    if (mAtualizaTelemetria)    {        mAtualizaTelemetria = false;        return(2);    }    else    {        return (0);    }}void RaceDirectorPlugin::UpdateTelemetry(const TelemInfoV01& info){    double velMPH = sqrt(info.mLocalVel.x * info.mLocalVel.x + info.mLocalVel.y * info.mLocalVel.y + info.mLocalVel.z * info.mLocalVel.z) * 2.23694;    double velKPH = sqrt(info.mLocalVel.x * info.mLocalVel.x + info.mLocalVel.y * info.mLocalVel.y + info.mLocalVel.z * info.mLocalVel.z) * 3.6;        for(auto& piloto : mPilotos)    {        if (piloto.mID == info.mID)        {            piloto.mVelMPH = velMPH;            piloto.mVelKPH = velKPH;            piloto.mMarcha = info.mGear;            piloto.mLimitador = info.mSpeedLimiter;        }	}}bool RaceDirectorPlugin::WantsToDisplayMessage(MessageInfoV01 &msgInfo){    if (!mMensagem.empty()) {        strcpy_s(msgInfo.mText, mMensagem.c_str());        msgInfo.mDestination = 1;        msgInfo.mTranslate = 0;        EscreverLog("Mensagem enviada: " + mMensagem);        mMensagem.clear(); // Limpar a mensagem após enviá-la.        return true;    }    return false;}void RaceDirectorPlugin::SetEnvironment(const EnvironmentInfoV01 &info){    mLogLocal = string(info.mPath[0]) + "Log\\RaceDirector\\";    if (!fs::exists(mLogLocal))    {        fs::create_directories(mLogLocal);    }}bool RaceDirectorPlugin::GetCustomVariable(long i, CustomVariableV01 &var){    switch (i)    {    case 0:        strcpy_s(var.mCaption, " Enabled");        var.mNumSettings = 2;        var.mCurrentSetting = 1;        return(true); // rF2 criará automaticamente esta variável e a padronizará como 1 (true), a menos que a criemos primeiro, caso em que podemos escolher o padrão.    case 1:        strcpy_s(var.mCaption, "LogRegister");        var.mNumSettings = 2;        var.mCurrentSetting = 1;        return(true);    case 2:        strcpy_s(var.mCaption, "Language");        var.mNumSettings = 2;        var.mCurrentSetting = 0;        return(true);     case 3:        strcpy_s(var.mCaption, "StartControl.Enabled");        var.mNumSettings = 2;        var.mCurrentSetting = 1;        return(true);    case 4:        strcpy_s(var.mCaption, "StartControl.Gear");        var.mNumSettings = 3;        var.mCurrentSetting = 2;        return(true);    case 5:        strcpy_s(var.mCaption, "StartControl.Limiter");        var.mNumSettings = 2;        var.mCurrentSetting = 1;        return(true);    case 6:        strcpy_s(var.mCaption, "StartControl.MaxSpeedKPH");        var.mNumSettings = 301;        var.mCurrentSetting = 80;        return(true);    case 7:        strcpy_s(var.mCaption, "StartControl.Penalty");        var.mNumSettings = 4;        var.mCurrentSetting = -1;        return(true);    }    return(false);}void RaceDirectorPlugin::GetCustomVariableSetting(CustomVariableV01 &var, long i, CustomSettingV01 &setting){    if (0 == _stricmp(var.mCaption, " Enabled"))    {        if (0 == i)            strcpy_s(setting.mName, "False");        else if (1 == i)            strcpy_s(setting.mName, "True");    }    else if (0 == _stricmp(var.mCaption, "LogRegister"))    {        if (0 == i)            strcpy_s(setting.mName, "False");        else if (1 == i)            strcpy_s(setting.mName, "True");    }    else if (0 == _stricmp(var.mCaption, "Language"))    {        if (0 == i)            strcpy_s(setting.mName, "EN");        else if (1 == i)            strcpy_s(setting.mName, "PT");    }    else if (0 == _stricmp(var.mCaption, "StartControl.Enabled"))    {        if (0 == i)            strcpy_s(setting.mName, "False");        else if (1 == i)            strcpy_s(setting.mName, "True");    }    else if (0 == _stricmp(var.mCaption, "StartControl.Gear"))    {        if (0 == i)            strcpy_s(setting.mName, "Disabled");        else if (1 == i)            strcpy_s(setting.mName, "1st");        else if (2 == i)            strcpy_s(setting.mName, "2nd");    }    else if (0 == _stricmp(var.mCaption, "StartControl.Limiter"))    {        if (0 == i)            strcpy_s(setting.mName, "Disabled");        else if (1 == i)            strcpy_s(setting.mName, "Enabled");    }    else if (0 == _stricmp(var.mCaption, "StartControl.MaxVelKPH"))    {        if (0 == i)            strcpy_s(setting.mName, "Disabled");        else if (80 == i)            strcpy_s(setting.mName, "80kph");    }    else if (0 == _stricmp(var.mCaption, "StartControl.Penalty"))    {        if (i == -3)            strcpy_s(setting.mName, "Disabled");        else if (i == -2)            strcpy_s(setting.mName, "Longest Line");        else if (i == -1)            strcpy_s(setting.mName, "Drive-Thru");        else if (i == 10)            strcpy_s(setting.mName, "Stop&Go 10s");    }}void RaceDirectorPlugin::AccessCustomVariable(CustomVariableV01 &var){    if (0 == _stricmp(var.mCaption, " Enabled"))    {        // Nao faca nada; esta variavel e apenas para o rF2 saber se deve manter o plugin carregado.    }    else if (0 == _stricmp(var.mCaption, "LogRegister"))    {        mLogHabilitado = ( var.mCurrentSetting != 0 );    }    else if (0 == _stricmp(var.mCaption, "Language"))    {        mIdioma = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Enabled"))    {        mStartControlEnabled = (var.mCurrentSetting != 0);    }    else if (0 == _stricmp(var.mCaption, "StartControl.Gear"))    {        mStartControlGear = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Limiter"))    {        mStartControlLimiter = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.MaxVelKPH"))    {        mStartControlMaxVelKPH = var.mCurrentSetting;    }    else if (0 == _stricmp(var.mCaption, "StartControl.Penalty"))    {        mStartControlPenalty = var.mCurrentSetting;    }}void RaceDirectorPlugin::GerarLog(){    auto agora = chrono::system_clock::now();    time_t t = chrono::system_clock::to_time_t(agora);    tm now;    localtime_s(&now, &t);    ostringstream oss;    oss << mLogLocal << "RD-" << put_time(&now, "%Y_%m_%d-%H_%M_%S") << ".txt";    mLogLocal = oss.str();    mLogArquivo.open(mLogLocal, ios::app);}// Escrever o Log no arquivo criadovoid RaceDirectorPlugin::EscreverLog(const string& msg){    ostringstream log;    if (mLogHabilitado && mLogArquivo.is_open())    {        mLogArquivo << msg << endl;    }}void RaceDirectorPlugin::CheckStartControl(){    if (mStartControlEnabled)    {        EscreverLog("Bandeira VERDE, iniciando controle de Largada...");        for (auto& piloto : mPilotos)        {            if (!piloto.mEmPit)            {                ostringstream log;                if (piloto.mVelKPH > mStartControlMaxVelKPH)                {                    mAplicaPenalidade = true;                    log << "Velocidade excedida: " << piloto.mNome << " (" << piloto.mVelKPH << " km/h" << ")";                }                else if (piloto.mMarcha != mStartControlGear)                {                    mAplicaPenalidade = true;                    log << "Marcha incorreta: " << piloto.mNome << " (Marcha: " << piloto.mMarcha << ")";                }                else if (piloto.mLimitador != mStartControlLimiter)                {                    mAplicaPenalidade = true;                    log << "Limitador desligado: " << piloto.mNome;                }                if (mAplicaPenalidade)                {                    ostringstream oss;                    oss << "/addpenalty " << mStartControlPenalty << " " << piloto.mNome;                    mMensagem = oss.str();                    EscreverLog(log.str()); // Log da penalidade aplicada.                }                else                {                    EscreverLog("Piloto " + piloto.mNome + " cumpriu os requisitos de largada."); // Log de sucesso.                }            }         }    }}